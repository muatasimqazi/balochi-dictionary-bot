'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _row = require('./row');

var _row2 = _interopRequireDefault(_row);

var _error = require('./error');

var _error2 = _interopRequireDefault(_error);

var _util = require('./util');

var util = _interopRequireWildcard(_util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Get useful information about the response.
var Response = function () {
  function Response(request) {
    _classCallCheck(this, Response);

    this.request = request;
    this.options = request.options;
  }

  _createClass(Response, [{
    key: 'setAttributes',
    value: function setAttributes() {
      var fetchSize = this.options.user.fetchSize;
      var rows = this.raw.table.rows;
      var cols = this.raw.table.cols;

      // Initialize a hash for the response attributes.
      var attributes = {
        last: rows.length - 1,
        rowNumberOffset: this.request.state.header || 0
      };

      // Determine if Google has extracted column labels from a header row.
      var columnLabels = this.request.state.labels;
      if (!this.request.state.offset) {
        // Use extracted column labels, the first row, or column letter.
        columnLabels = cols.map(function (col, i) {
          if (col.label) {
            return col.label.replace(/\s/g, '');
          }

          // Get column labels from the first row of the response.
          attributes.last += 1;
          attributes.rowNumberOffset = 1;
          return util.getCellValue(rows[0].c[i]) || col.id;
        });

        this.request.update({
          header: attributes.rowNumberOffset,
          labels: columnLabels,
          offset: this.request.state.offset + attributes.rowNumberOffset
        });
      }

      // The Google API generates an unrecoverable error when the 'offset' is
      // larger than the number of available rows, which is problematic for
      // paged requests. As a workaround, we request one more row than we need
      // and stop when we see less rows than we requested.

      // Remember whether this request has been fully loaded.
      if (!fetchSize || rows.length - attributes.rowNumberOffset < fetchSize) {
        attributes.last += 1;
        this.request.update({ loaded: true });
      }

      // If column labels are provided and have the expected length, use them.
      var userLabels = this.options.user.labels;
      var userLabelsValid = userLabels && userLabels.length === columnLabels.length;
      attributes.labels = userLabelsValid ? userLabels : columnLabels;

      // Return the response attributes.
      this.attributes = attributes;
    }

    // Parse data, row by row, and generate a simpler output array.

  }, {
    key: 'setOutput',
    value: function setOutput() {
      var _this = this;

      this.rows = [];

      // Add a header row constructed from the column labels, if appropriate.
      if (!this.request.state.offset && !this.attributes.rowNumberOffset) {
        this.rows.push(new _row2.default(0, this.attributes.labels, this.attributes.labels));
      }

      // Each table cell ('c') can contain two properties: 'p' contains
      // formatting and 'v' contains the actual cell value.

      // Loop through each table row.
      this.raw.table.rows.forEach(function (row, i) {
        // Proceed if the row has cells and the row index is within the targeted
        // range. (This avoids displaying too many rows when paging data.)
        if (row.c && i < _this.attributes.last) {
          // Get the "real" row index (not counting header rows). Create a row
          // object and add it to the output array.
          var counter = _this.request.state.offset + i + 1 - _this.attributes.rowNumberOffset;
          _this.rows.push(new _row2.default(counter, row.c, _this.attributes.labels));
        }
      });

      // Remember the new row offset.
      this.request.update({
        offset: this.request.state.offset + this.options.user.fetchSize
      });
    }

    // Generate HTML from rows using a template.

  }, {
    key: 'setHTML',
    value: function setHTML() {
      var target = this.options.user.target;
      var template = this.options.user.rowTemplate || util.toHTML;
      var isTable = util.isTable(target);
      var needsHeader = target && util.hasClass(target, 'sheetrock-header');

      // Pass each row to the row template. Only parse header rows if the target
      // is a table or indicates via className that it wants the header.
      var headerHTML = '';
      var bodyHTML = '';
      this.rows.forEach(function (row) {
        if (row.num) {
          bodyHTML += template(row);
        } else if (isTable || needsHeader) {
          headerHTML += template(row);
        }
      });

      if (isTable) {
        headerHTML = util.wrapTag(headerHTML, 'thead');
        bodyHTML = util.wrapTag(bodyHTML, 'tbody');
      }

      util.append(target, headerHTML + bodyHTML);

      this.html = headerHTML + bodyHTML;
    }

    // Load API response.

  }, {
    key: 'loadData',
    value: function loadData(rawData, callback) {
      this.raw = rawData;

      try {
        this.setAttributes();
        this.setOutput();
      } catch (error) {
        callback(new _error2.default('Unexpected API response format.'));
        return;
      }

      // Don't catch errors thrown in setHTML; let the user handle them.
      this.setHTML();
      callback(null);
    }
  }]);

  return Response;
}();

exports.default = Response;
module.exports = exports['default'];