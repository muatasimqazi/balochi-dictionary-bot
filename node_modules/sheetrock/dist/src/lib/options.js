'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _config = require('./config');

var config = _interopRequireWildcard(_config);

var _util = require('./util');

var _error = require('./error');

var _error2 = _interopRequireDefault(_error);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Support some legacy option names.
function translateLegacyOptions(options) {
  var newOptions = {};

  Object.keys(options).forEach(function (key) {
    if ({}.hasOwnProperty.call(config.legacyOptions, key)) {
      newOptions[config.legacyOptions[key]] = options[key];
    } else {
      newOptions[key] = options[key];
    }
  });

  return newOptions;
}

function setUserOptions(options) {
  var validatedOptions = {};

  // Look for valid DOM element target.
  validatedOptions.target = (0, _util.extractElement)(options.target);

  // Correct bad integer values.
  validatedOptions.fetchSize = Math.max(0, parseInt(options.fetchSize, 10) || 0);

  // Require DOM element or a callback function. Otherwise, the data has nowhere to go.
  if (!validatedOptions.target && !options.callback && !config.defaults.callback) {
    throw new _error2.default('No element targeted or callback provided.');
  }

  // Extend default options.
  return _extends({}, config.defaults, options, validatedOptions);
}

function setRequestOptions(options, data) {
  // If the user passed data, we don't want to validate the URL.
  if (data) {
    return { data: data };
  }

  // Get API endpoint, key, and gid from a Google Sheet URL.
  var sheetType = null;
  Object.keys(config.sheetTypes).forEach(function (key) {
    var value = config.sheetTypes[key];
    if (value.keyFormat.test(options.url) && value.gidFormat.test(options.url)) {
      sheetType = value;
    }
  });

  if (sheetType) {
    var sheetKey = options.url.match(sheetType.keyFormat)[1];
    return {
      key: sheetKey,
      gid: options.url.match(sheetType.gidFormat)[1],
      apiEndpoint: sheetType.apiEndpoint.replace('%key%', sheetKey)
    };
  }

  // Require a Sheet key and gid.
  throw new _error2.default('No key/gid in the provided URL.');
}

var Options = function Options() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  _classCallCheck(this, Options);

  this.user = setUserOptions(translateLegacyOptions(options));
  this.request = setRequestOptions(this.user, data);

  // Generate a request ID that can be used as a caching key.
  this.requestIndex = this.request.key + '_' + this.request.gid + '_' + this.user.query;
};

exports.default = Options;
module.exports = exports['default'];